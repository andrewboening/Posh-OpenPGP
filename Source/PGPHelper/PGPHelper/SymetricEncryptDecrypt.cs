using System;
using System.IO;
using System.Text;
using Org.BouncyCastle.Bcpg.OpenPgp;
using Org.BouncyCastle.Bcpg;
using Org.BouncyCastle.Security;
using Org.BouncyCastle.Utilities.IO;

namespace PGPHelper
{
    public static class SymmetricFileProcessor
    {

        /// <summary>
        /// 
        /// </summary>
        /// <param name="inputStream"></param>
        /// <param name="outFile"></param>
        /// <param name="passPhrase"></param>
        public static void DecryptFile(
            Stream inputStream,
            string outFile,
            char[] passPhrase)
        {
            inputStream = PgpUtilities.GetDecoderStream(inputStream);

            var pgpF = new PgpObjectFactory(inputStream);
            var o = pgpF.NextPgpObject();

            //
            // the first object might be a PGP marker packet.
            //
            var enc = o as PgpEncryptedDataList;
            if (enc == null)
            {
                enc = (PgpEncryptedDataList)pgpF.NextPgpObject();
            }

            var pbe = (PgpPbeEncryptedData)enc[0];
            var clear = pbe.GetDataStream(passPhrase);

            var pgpFact = new PgpObjectFactory(clear);

            //
            // if we're trying to read a file generated by someone other than us
            // the data might not be compressed, so we check the return type from
            // the factory and behave accordingly.
            //
            o = pgpFact.NextPgpObject();
            if (o is PgpCompressedData)
            {
                var cData = (PgpCompressedData)o;
                pgpFact = new PgpObjectFactory(cData.GetDataStream());
                o = pgpFact.NextPgpObject();
            }
            var ld = (PgpLiteralData)o;
            var unc = ld.GetInputStream();
            Stream fOut = File.Create(outFile);
            Streams.PipeAll(unc, fOut);
            fOut.Close();

            if (pbe.IsIntegrityProtected())
            {
                if (!pbe.Verify())
                {
                    Console.Error.WriteLine("Message failed integrity check");
                }
                else
                {
                    Console.Error.WriteLine("Message integrity check passed");
                }
            }
            else
            {
                Console.Error.WriteLine("No message integrity check");
            }
        }
   
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="inStream"></param>
        /// <param name="outStream"></param>
        /// <param name="symmAlgorithm"></param>
        /// <param name="passPhrase"></param>
        /// <param name="armor"></param>
        /// <param name="compressionName"></param>
        /// <param name="withIntegrityCheck"></param>
        public static void Encrypt(
            FileStream inStream,
            Stream outStream,
            string symmAlgorithm,
            char[] passPhrase,
            bool armor,
            string compressionName,
            bool withIntegrityCheck)
        {
            if (armor)
            {
                outStream = new ArmoredOutputStream(outStream);
            }

            // Select the specified compression
            CompressionAlgorithmTag comptype;

            if (string.Equals(compressionName, "Uncompressed", StringComparison.CurrentCultureIgnoreCase))
            {
                comptype = CompressionAlgorithmTag.Uncompressed;
            }
            else if (string.Equals(compressionName, "Zip", StringComparison.CurrentCultureIgnoreCase))
            {
                comptype = CompressionAlgorithmTag.Zip;
            }
            else if (string.Equals(compressionName, "Zlib", StringComparison.CurrentCultureIgnoreCase))
            {
                comptype = CompressionAlgorithmTag.ZLib;
            }
            else if (string.Equals(compressionName, "BZip2", StringComparison.CurrentCultureIgnoreCase))
            {
                comptype = CompressionAlgorithmTag.BZip2;
            }
            else
            {
                comptype = CompressionAlgorithmTag.Zip;
            }

            SymmetricKeyAlgorithmTag symtype;

            if (string.Equals(symmAlgorithm, "Aes256", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Aes256;
            }
            else if (string.Equals(symmAlgorithm, "Aes192", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Aes192;
            }
            else if (string.Equals(symmAlgorithm, "Aes128", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Aes128;
            }
            else if (string.Equals(symmAlgorithm, "Blowfish", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Blowfish;
            }
            else if (string.Equals(symmAlgorithm, "Twofish", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Twofish;
            }
            else if (string.Equals(symmAlgorithm, "Cast5", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Cast5;
            }
            else if (string.Equals(symmAlgorithm, "Idea", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Idea;
            }
            else
            {
                symtype = SymmetricKeyAlgorithmTag.Twofish;
            }

            // Create Encryption Generator
            var encGen = new PgpEncryptedDataGenerator(symtype, withIntegrityCheck, new SecureRandom());
            encGen.AddMethod(passPhrase);

            // Initialize compressor
            var compressedOut = new MemoryStream();
            var comData = new PgpCompressedDataGenerator(comptype);


            PgpUtilities.WriteFileToLiteralData(comData.Open(compressedOut), PgpLiteralData.Binary,
            new FileInfo(inStream.Name));
            comData.Close();

            //Save encrypted data in to the stream.
            var compressData = compressedOut.ToArray();
            var encOut = encGen.Open(outStream, compressData.Length);
            encOut.Write(compressData, 0, compressData.Length);
            encOut.Close();

            if (armor)
            {
                outStream.Close();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="bs"></param>
        /// <returns></returns>
        public static string GetAsciiString(byte[] bs)
        {
            return Encoding.ASCII.GetString(bs, 0, bs.Length);
        }
    }
}
