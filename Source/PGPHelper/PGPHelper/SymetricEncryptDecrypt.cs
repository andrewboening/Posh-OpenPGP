using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using Org.BouncyCastle.Bcpg.OpenPgp;
using Org.BouncyCastle.Bcpg;
using Org.BouncyCastle.Security;
using Org.BouncyCastle.Utilities.Encoders;
using Org.BouncyCastle.Utilities.IO;

namespace PGPHelper
{
    public static class SymmetricFileProcessor
    {

        /**
        * decrypt the passed in message stream
        */
        public static void DecryptFile(
            Stream inputStream,
            string outFile,
            char[] passPhrase)
        {
            inputStream = PgpUtilities.GetDecoderStream(inputStream);

            PgpObjectFactory pgpF = new PgpObjectFactory(inputStream);
            PgpObject o = pgpF.NextPgpObject();

            //
            // the first object might be a PGP marker packet.
            //
            PgpEncryptedDataList enc = o as PgpEncryptedDataList;
            if (enc == null)
            {
                enc = (PgpEncryptedDataList)pgpF.NextPgpObject();
            }

            PgpPbeEncryptedData pbe = (PgpPbeEncryptedData)enc[0];
            Stream clear = pbe.GetDataStream(passPhrase);

            PgpObjectFactory pgpFact = new PgpObjectFactory(clear);

            //
            // if we're trying to read a file generated by someone other than us
            // the data might not be compressed, so we check the return type from
            // the factory and behave accordingly.
            //
            o = pgpFact.NextPgpObject();
            if (o is PgpCompressedData)
            {
                PgpCompressedData cData = (PgpCompressedData)o;
                pgpFact = new PgpObjectFactory(cData.GetDataStream());
                o = pgpFact.NextPgpObject();
            }
            PgpLiteralData ld = (PgpLiteralData)o;
            Stream unc = ld.GetInputStream();
            Stream fOut = File.Create(outFile);
            Streams.PipeAll(unc, fOut);
            fOut.Close();

            if (pbe.IsIntegrityProtected())
            {
                if (!pbe.Verify())
                {
                    Console.Error.WriteLine("Message failed integrity check");
                }
                else
                {
                    Console.Error.WriteLine("Message integrity check passed");
                }
            }
            else
            {
                Console.Error.WriteLine("No message integrity check");
            }
        }

        public static void Encrypt(
            FileStream inStream,
            Stream outStream,
            string symmAlgorithm,
            char[] passPhrase,
            bool armor,
            string compressionName,
            bool withIntegrityCheck)
        {
            if (armor)
            {
                outStream = new ArmoredOutputStream(outStream);
            }

            // Select the specified compression
            CompressionAlgorithmTag comptype;

            if (string.Equals(compressionName, "Uncompressed", StringComparison.CurrentCultureIgnoreCase))
            {
                comptype = CompressionAlgorithmTag.Uncompressed;
            }
            else if (string.Equals(compressionName, "Zip", StringComparison.CurrentCultureIgnoreCase))
            {
                comptype = CompressionAlgorithmTag.Zip;
            }
            else if (string.Equals(compressionName, "Zlib", StringComparison.CurrentCultureIgnoreCase))
            {
                comptype = CompressionAlgorithmTag.ZLib;
            }
            else if (string.Equals(compressionName, "BZip2", StringComparison.CurrentCultureIgnoreCase))
            {
                comptype = CompressionAlgorithmTag.BZip2;
            }
            else
            {
                comptype = CompressionAlgorithmTag.Zip;
            }

            SymmetricKeyAlgorithmTag symtype;

            if (string.Equals(symmAlgorithm, "Aes256", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Aes256;
            }
            else if (string.Equals(symmAlgorithm, "Aes192", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Aes192;
            }
            else if (string.Equals(symmAlgorithm, "Aes128", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Aes128;
            }
            else if (string.Equals(symmAlgorithm, "Blowfish", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Blowfish;
            }
            else if (string.Equals(symmAlgorithm, "Twofish", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Twofish;
            }
            else if (string.Equals(symmAlgorithm, "Cast5", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Cast5;
            }
            else if (string.Equals(symmAlgorithm, "Idea", StringComparison.CurrentCultureIgnoreCase))
            {
                symtype = SymmetricKeyAlgorithmTag.Idea;
            }
            else
            {
                symtype = SymmetricKeyAlgorithmTag.Twofish;
            }

            // Create Encryption Generator
            PgpEncryptedDataGenerator encGen = new PgpEncryptedDataGenerator(symtype, withIntegrityCheck, new SecureRandom());
            encGen.AddMethod(passPhrase);

            // Initialize compressor
            MemoryStream compressedOut = new MemoryStream();
            PgpCompressedDataGenerator comData = new PgpCompressedDataGenerator(comptype);


            PgpUtilities.WriteFileToLiteralData(comData.Open(compressedOut), PgpLiteralData.Binary,
            new FileInfo(inStream.Name));
            comData.Close();

            //Save encrypted data in to the stream.
            byte[] CompressData = compressedOut.ToArray();
            Stream encOut = encGen.Open(outStream, CompressData.Length);
            encOut.Write(CompressData, 0, CompressData.Length);
            encOut.Close();

            if (armor)
            {
                outStream.Close();
            }
        }


        public static string GetAsciiString(byte[] bs)
        {
            return Encoding.ASCII.GetString(bs, 0, bs.Length);
        }
    }
}
